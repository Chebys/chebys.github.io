一段Jua代码是一段字符序列，可以包含ascii字符和非ascii字符。其可以被解析为函数体。
非ascii字符只能出现在字面字符串中。参见字面字符串。
一个Jua文件是一个文本文件，其内容为一段Jua代码。
* 不对文件的编码作规定，只要求实现能够识别其中的ascii字符。
Jua文件可以作为模块加载。
一个Jua程序由一个入口模块和若干依赖模块构成。（严格来说只要入口模块即可，因为模块均是动态加载的）

函数体是语句块的一种。
语句块由若干条语句构成。部分特殊语句只能在特定语句块中使用。

执行一个Jua程序的过程会产生各种值。值的类型有：空(null)，数字(number)，字符串(string)，布尔(boolean)，对象(object)，函数(function)。
字符串表示一个不可变的字节序列。字符串可以容纳任意 8 位值。Jua 的字符串不依赖于编码。
* 一些内置函数（如 Number.toString）可能产生ascii编码的字符串。
Jua程序具有标准输出和标准错误，由宿主程序实现。Jua程序可以向标准输出写入任意值，向标准错误中写入Error对象。
* 是否以及如何将写入值转换为字符串由宿主程序决定。
* 宿主程序也可以选择忽略标准输出和标准错误，只要程序能按预期运行即可。

对象以键值对形式储存信息，称作属性，可以有多对。键必须是字符串，值可以是任何类型。键不能重复。
Jua可以对属性进行设置、访问、删除操作。

值可以有内部属性。内部属性在Jua中不可见，仅用于抽象操作。
任何值均有原型，用于规定值的特殊行为。原型是值的内部属性。
每个值的原型有且仅有一个，要么是对象，要么是null。
原型的方法称作元方法（可继承）。
二元运算符重载优先使用左操作数的元方法。

执行一个语句块，需要将一个对象作为父作用域，并生成一个新的对象作为当前作用域。父作用域是作用域的内部属性。
执行一个Jua程序会产生一个贯穿始终的作用域，称作全局作用域；其后执行入口模块。
执行一个模块，需要将全局作用域作为父作用域以执行模块函数体。
执行一般函数的函数体，需要将函数定义所在作用域作为父作用域。
执行复合语句的语句块，需要将复合语句所在作用域作为父作用域。
语句块执行完毕后，对其作用域进行垃圾回收（todo）

进程有两种运行模式：单任务和多任务。
单任务模式中，进程会在入口模块执行完毕后退出。
多任务模式中，进程不会自动退出。退出方式取决于实现。可以使用 await/async 语法（todo）。

称作用域的属性为变量，属性名为变量命。
特别地，称全局作用域的属性为全局变量。

==语法==
一段Jua代码由若干语句构成。
语句有不同种类，可以分为简单语句和复合语句。
常见的语句是表达式语句，仅包含一个表达式。
* 除表达式语句以外的语句均以关键字开头。
表达式由若干初等表达式和二元运算符组成。
表达式可以是左值或右值。
* 左值/右值是语法上的概念，并不是真正的值。只有右值能被求值。
* 表达式是广义的，可以既不是左值也不是右值，这种表达式不合法，仅在解析时作为临时语法结构。
表达式的语法是贪心的。即，解析表达式时会匹配之后尽量多的语素作为表达式的一部分。
* 这可能导致一些陷阱。如果没有句末分号的习惯，在句首使用 '{' / '[' / '(' / 字面字符串（以上称作“危险语句”）时需要特别小心。建议之前加上分号。

===初等表达式===
标识符，左值、右值
（部分）关键字，右值
字面数字，右值
字面字符串，右值
括号表达式，可为右值
一元表达式，可为右值
三元表达式，右值
字面对象，可为左值、右值
字面数组，可为左值、右值
字面函数，右值
属性引用，可为左值、右值
可选属性引用，可为右值
方法包装，可为右值
可选方法调用，可为右值
抽取，可为左值、右值
调用，可为右值
====字面字符串====
目前仅支持单引号字符串。
字面字符串以一定规则转换为Jua字符串（字节串）。包括转义和编码两部分。
转义：将字面字符串的字符序列转换为原始字符序列。采用常用规则，如\n \0 \x \u。
特别地，\xXX 直接表示一个字节，无需编码。
编码：将字符序列转换为字节串。不规定具体编码，只要求将 ascii 字符编码为单字节。
* 如果标准输出需要显示Jua字符串，建议使用一致的编码规则。
** 建议都使用utf8编码。
* Jua的使用者可能需要关心：解释器能否区分代码中的ascii字符的非ascii字符？解释器如何将非ascii字符编码为字节串？输出端接收何种编码？
** 如果解释器同时承担了输出端的责任，通常不会出现编码问题。
todo: 双引号字符串，反引号字符串
====三元表达式====
if(右值) 右值 else 右值
====字面对象====
{ } 或 { 表达式列表 }
前一种表示是右值。
若 表达式列表 仅包含 属性声明，则该字面对象为右值。
若 表达式列表 非空且仅包含 左值属性声明，则该字面对象为左值。（左值对象）
* 以上两者可以同时满足。
左值对象末尾可带"?"，相当于所有属性的默认值（如果没有手动规定）为null。
====属性键====
标识符，或单元素右值数组。
====属性声明====
标识符，或 属性键 = 右值，或 方法声明。
====方法声明====
标识符 函数尾
====左值属性声明====
标识符 或 标识符 = 右值 或 属性键 as 声明项。
总是解析为 属性键 as 声明项。
====声明项====
可声明左值，或 可声明左值?，或 可声明左值 = 右值。
右值表示默认值（显式规定）
可声明左值? 表示自动添加默认值。
* 具体来说，若未显式规定默认值，则将默认值设为null；若可声明左值为 左值对象/左值数组，则递归地对子声明项自动添加默认值。
* 例如，{a, b=1, c as {d, e}}? 等价于 {a=null, b=1, c as {d=null, e=null}=null}=null
对声明项进行声明，可以提供初始值，若未提供则使用默认值。声明前，外部调用者需要检查并负责报错。
====可声明左值====
标识符 或 左值对象 或 左值数组

====字面数组====
[ ] 或 [ 表达式列表 ]
前一种表示是右值。
若 表达式列表 仅包含右值和星号表达式（星号表达式必须排在后），则该字面数组为右值。
若 表达式列表 为 声明列表 ，则该字面数组为左值。

====字面函数====
fun 函数尾 或 fun 参数列表 = 右值
* 当fun位于语句开头时，会解析为函数声明。
====函数尾====
参数列表 语句块
====参数列表====
一对括号，内部为空或 声明列表。
====声明列表====
逗号分隔的 声明项 列表。最后一项可以是星号表达式。
====星号表达式====
"*" 标识符

====方法包装====
右值:标识符

====调用====
右值(可空表达式列表)
右值 字面字符串
右值 函数尾
右值 语句块
* 没有默认值的参数需要显式传入，否则报错
* 传入的参数可以多于声明的参数，会忽略
try{
	trysomething
}:catch(err){
	dosthwitherr
}
等价于
try(fun(){
	trysomething
}):catch(fun(err){
	dosthwitherr
})
===运算符===
略
.. range运算符

以下若无特别说明，表达式均指右值。
===简单语句===
简单语句末尾可以带有分号作为分隔。方便起见，下面所说的语句不含末尾分号。
* 建议：要么所有简单语句后加分号，要么都不加，而是在“危险语句”前加分号。
* 简单语句和复合语句仅有语法上的区别，解析后并不会加以区分。
空语句
表达式语句
变量声明语句
return语句
continue语句
break语句
====变量声明语句====
let 变量声明列表
====变量声明列表====
逗号分隔的 声明项 列表。未显式规定默认值的声明项的默认值自动设为null（不包括子声明项）。
声明时不提供初始值，也就是所有声明项使用默认值。
====return语句====
return 右值
* 不能省略返回值，否则解析起来很麻烦

===复合语句===
if, switch, for, while
函数声明在语法上属于复合语句，但解析后会转换为变量声明语句。
====if语句====
if(a){
	xxx
}else if(b){
	xxx
}
等价于
if(a){
	xxx
}else{
	if(b){
		xxx
	}
}
====switch语句====
switch(val)
	case(m1){
		xxx
	}case(m2, m3){
		xxx
	}else{
		xxx
	}
====for语句====
for...in
====函数声明====
fun 标识符 函数尾
或 fun 标识符 参数列表 = 表达式
* 会被转译为 let 标识符 = 字面函数
====扩展函数====
fun 属性引用 函数尾
或 fun 属性引用 参数列表 = 表达式
* 会被转译为 属性引用 = 字面函数
* 注意，没有 fun obj:meth(...){...} 语法

==抽象操作==
===严格属性访问===
若目标为对象，则访问对象自身属性。
否则，属性不存在。
===属性访问===
尝试严格属性访问。
若属性不存在，则进行继承属性访问。
若属性仍不存在，则报错。ReferenceError
===继承属性访问===
对目标obj（未必为对象）进行继承属性访问：
若目标为作用域，则对其父作用域进行属性访问。
否则：
若obj没有原型，则属性不存在。
否则，设原型为proto。
若proto.isClass（严格属性访问）为true，则对obj.super（严格属性访问）进行属性访问。
否则，对proto进行属性访问。
（简而言之，普通对象或值从原型继承属性，类从父类继承属性，作用域从父作用域继承属性）
===可选属性访问===
类似属性访问，但属性仍不存在时不报错，而是返回null。
===迭代===
对迭代目标进行迭代，以产生一系列值。
若迭代目标具有iter元方法，则称该目标为迭代器，iter元方法为迭代函数，并进行迭代器迭代。
否则，若迭代目标为对象，则进行属性迭代。
否则，迭代失败。
====属性迭代====
产生迭代目标（对象）的所有自身属性。
* 次序未定义，取决于实现。
====迭代器迭代====
while(true)
	{done, value?, key?} = iter(target, key)
	if(done)
		break
	yield value
* 若 iter(target, key).done 为真，且未在迭代函数之外改变target状态，则该表达式应当总是为真（无论调用多少次）。否则，行为未定义。
* 如果迭代函数严格按照key来生成值（不改变迭代器状态），则该迭代器是可重复使用的。可以将其包装为一次性迭代器。

==内置值==
部分内置值以全局变量的形式存在。
* 尽管是变量，不建议改变它们。
===内置函数===
class, print, require, throw, try, type, useNS
===内置类===
Object, Number, String, Boolean, Function, Array, Buffer, Error, Range（非全局变量）
内置类的内置属性不应被改变，否则行为未定义。
Buffer: 一段可以读写字节串的固定长度的区域。可以位于任何硬件（取决于实现）
具体的内置属性，参见Jua源码。

==内置模块==
可以直接通过require导入（无需查找模块文件）的模块。
===标准内置模块===
math, regex, json, date, promise
package?
* 官方实现中（暂未实现）的非标准内置模块：fs, unicode, http, base64, cli

==术语==
以字面对象或字面数组为左操作数的赋值表达式称作解构赋值。

字节串和字符串是同义词。

若一个对象的原型的 isClass 属性（严格属性访问）为true，则称该对象为类。
若一个值的原型为类，则称该值为该类的实例。
* 类一定是对象，而实例不一定是对象。
若一个类c1具有super属性且属性值为类c2，则称c2为c1的父类。（若属性值为普通对象？）。c1为c2的子类。
规定子类的实例也是父类的实例。
若一个类是可调用的（通过call元方法），且返回值为类实例，则称该类为可构造类。
若一个类的call元方法为Object.new，则称该类为标准可构造类。
* 标准可构造类的构造函数总是返回新的对象。（而不是已有的对象或其他类型的值）
* 内置类往往是可构造类，但不是标准可构造类。
* class函数总是返回标准可构造类。
* 标准可构造类不应继承自非标准可构造类（无法得到预期的效果）。这意味着class函数无法产生非标准可构造类的子类。

除原型外没有其他内部属性的对象称作纯净对象。
使用字面对象产生的对象总是纯净对象。
类总是纯净对象。？
Jua语言设计的一个原则：能使用原型规定的信息尽量不使用内部属性。


==模拟==
Object.new = fun(proto, *args){
	let obj = {}
	Object.setProto(obj, proto)
	if(type(proto.init)=='function')
		proto.init(obj, *args)
	return obj
}
let classProto = { //实际上等于 Object:getProto()
	isClass = true,
	call = Object.new
}
//或者，更普适的：
let classProto = {
	isClass = true,
	call(proto, *args){
		let new = proto.new
		if(type(new)!='function')
			new = Object.new
		return new(proto, *args)
	}
}
fun class(proto){
	Object.setProto(proto, classProto)
	return proto
}